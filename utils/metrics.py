"""
This module generates and evaluates SMILES strings generated by our model.
It utilizes the RDKit library for molecular property calculations, MOSES metrics for generative model evaluation, 
and TorchMetrics for character error rate calculations.

Output:
Generates a table displaying various metrics including validity, novelty, character error rate, similarity score, 
and RMSE and R^2 scores for molecular properties.
"""

import pandas as pd
import sys
import random
from rdkit import Chem, RDLogger
from rdkit.Chem import AllChem, DataStructs, Descriptors
import torch
import numpy as np
from sklearn.metrics import mean_squared_error, r2_score
import torchmetrics
from tabulate import tabulate
import math
from typing import Dict, Any, List

sys.path.append('/data')
import moses
from moses.metrics.metrics import novelty, fraction_unique, fraction_valid
from moses.metrics.utils import SA

from generation import generate

RDLogger.DisableLog('rdApp.*')
random.seed(42)


def partial_smiles(item: Dict[str, Any], min_percentage: int = 25, max_percentage: int = 65) -> Dict[str, Any]:
    """
    Create a partial SMILES string from the input.

    Args:
        item (Dict[str, Any]): Input data dictionary.
        min_percentage (int): Minimum percentage of SMILES to keep.
        max_percentage (int): Maximum percentage of SMILES to keep.

    Returns:
        Dict[str, Any]: Modified input data with partial SMILES.
    """
    percentage = random.randint(min_percentage, max_percentage)
    cutoff = max(5, int(len(item['input']['SMILES']) * percentage / 100))  # Ensure at least five character
    item['input']['SMILES'] = item['input']['SMILES'][:cutoff]
    return item


def get_mol_props(smiles: str) -> Dict[str, Any]:
    """
    Calculate molecular properties.
    
    
    Args:
        smiles (str): SMILES string.

    Returns:
        Dict[str, Any]: Molecular properties for the given SMILES.
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    return {
        'MolecularWeight': Descriptors.ExactMolWt(mol),
        'LogP': Descriptors.MolLogP(mol),
        'HBD': Descriptors.NumHDonors(mol),
        'HBA': Descriptors.NumHAcceptors(mol),
        'TPSA': Descriptors.TPSA(mol),
        'RotatableBonds': Descriptors.NumRotatableBonds(mol),
        'QED': Descriptors.qed(mol),
        'SA_Score': SA(mol)
    }


def calculate_similarity(generated_smiles: List[str], reference_smiles: List[str]) -> float:
    """
    Calculate similarity between generated and reference SMILES.
    
    Args:
        generated_smiles (List[str]): List of the SMILES generated by the model.
        reference_smiles (List[str]): List of the ground-truth (expected) SMILES.
    """
    total_similarity = 0
    valid_count = 0
    for gen, ref in zip(generated_smiles, reference_smiles):
        gen_mol = Chem.MolFromSmiles(gen)
        ref_mol = Chem.MolFromSmiles(ref)
        if gen_mol is not None and ref_mol is not None:
            gen_fp = AllChem.GetMorganFingerprintAsBitVect(gen_mol, 2, nBits=1024)
            ref_fp = AllChem.GetMorganFingerprintAsBitVect(ref_mol, 2, nBits=1024)
            similarity = DataStructs.TanimotoSimilarity(gen_fp, ref_fp)
            total_similarity += similarity
            valid_count += 1
    return total_similarity / valid_count if valid_count > 0 else 0


def test(config: Dict[str, Any], test_file: str, train_file: str, min_percentage: int, max_percentage: int, weights: str = None, best: bool = False) -> List[Dict[str,str]]:
    """
    Generates and evaluates SMILES strings.

    Args:
        config (Dict[str, Any]): Configuration dictionary.
        test_file (str): Path to the test SMILES file.
        train_file (str): Path to the train SMILES file.
        min_percentage (int): Minimum percentage for creating partial SMILES.
        max_percentage (int): Maximum percentage for creating partial SMILES.
        weights (str, optional): Path to model weights file. If not provided, the latest weights will be used.
        best (bool, optional): If True, use the best model weights.
        
    Returns:
        List[Dict[str, str]]: List of dictionaries containing 'input_smiles' (partial SMILES) and 'output_smiles' (generated SMILES) keys.
    """ 
    df = pd.read_csv(test_file, header=None, names=['SMILES', 'MolecularWeight', 'LogP', 'HBD', 'HBA', 'TPSA', 'RotatableBonds', 'Scaffold', 'QED', 'SA_Score'])
    smiles_data = df.to_dict('records')
    smiles_test = df['SMILES'].to_list()

    data = []
    for smiles in smiles_data:
        if isinstance(smiles['Scaffold'], float) and math.isnan(smiles['Scaffold']):
            del smiles['Scaffold']
        data.append(partial_smiles({'input': smiles}))

    generated = generate(config, data, weights, best)
    generated_smiles = pd.DataFrame(generated)['output_smiles'].tolist()

    df_train = pd.read_csv(train_file)
    smiles_train = df_train['SMILES'].to_list()

    table_data = []
    
    # MOSES Metrics
    validity = fraction_valid(generated_smiles)
    novelty_score = novelty(generated_smiles, smiles_train)
    table_data.append(["Validity", f"{validity:.5f}"])
    table_data.append(["Novelty", f"{novelty_score:.5f}"])

    # Character Error Rate
    cer = torchmetrics.text.CharErrorRate()
    cer_score = cer(generated_smiles, smiles_test).item()
    table_data.append(["Character Error Rate", f"{cer_score:.5f}"])

    # Similarity Score
    similarity_score = calculate_similarity(generated_smiles, smiles_test)
    table_data.append(["Similarity Score", f"{similarity_score:.5f}"])

    # RMSE and R^2 for numerical properties
    properties = ['MolecularWeight', 'LogP', 'HBD', 'HBA', 'TPSA', 'RotatableBonds', 'QED', 'SA_Score']
    generated_props = [p for p in (get_mol_props(s) for s in generated_smiles) if p is not None]

    for prop in properties:
        true_values = df[prop].values[:len(generated_props)]
        generated_values = [p[prop] for p in generated_props]
        
        if generated_values:
            rmse = np.sqrt(mean_squared_error(true_values, generated_values))
            r2 = r2_score(true_values, generated_values)
            table_data.append([f"{prop}", f"RMSE: {rmse:.5f}", f"R^2: {r2:.5f}"])

    print(tabulate(table_data, headers=["Metric", "Value", ""], tablefmt="grid"))

    return generated